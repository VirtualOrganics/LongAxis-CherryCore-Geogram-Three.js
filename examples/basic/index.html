<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 250px;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 120px;
            font-size: 14px;
        }
        input[type="number"] {
            width: 60px;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div id="info">
        <h3>3D Periodic Delaunay-Voronoi Triangulation</h3>
        <div id="stats">Loading...</div>
    </div>
    
    <div id="controls">
        <h4>Controls</h4>
        <div class="control-group">
            <label>Periodic Mode:</label>
            <input type="checkbox" id="periodicMode">
        </div>
        <div class="control-group">
            <label>Number of Points:</label>
            <input type="number" id="numPoints" value="150" min="4" max="200">
        </div>
        <div class="control-group">
            <label>Min Distance:</label>
            <input type="number" id="minDistance" value="0.05" min="0.01" max="0.2" step="0.01">
        </div>
        <div class="control-group">
            <label>Poisson Sampling:</label>
            <input type="checkbox" id="poissonSampling" checked>
        </div>
        <hr>
        <div class="control-group">
            <label>Delaunay Size:</label>
            <input type="number" id="delaunaySize" value="0.005" min="0.005" max="0.05" step="0.005">
        </div>
        <div class="control-group">
            <label>Vertex Color:</label>
            <input type="color" id="vertexColor" value="#000000">
        </div>
        <div class="control-group">
            <label>Delaunay Edge Color:</label>
            <input type="color" id="delaunayEdgeColor" value="#808080">
        </div>
        <div class="control-group">
            <label>Voronoi Size:</label>
            <input type="number" id="voronoiSize" value="0.005" min="0.005" max="0.05" step="0.005">
        </div>
        <div class="control-group">
            <label>Voronoi Vertex Color:</label>
            <input type="color" id="voronoiVertexColor" value="#0000FF">
        </div>
        <div class="control-group">
            <label>Voronoi Edge Color:</label>
            <input type="color" id="voronoiEdgeColor" value="#4169E1">
        </div>
        <div class="control-group">
            <label>Tetra Color:</label>
            <input type="color" id="tetraColor" value="#D3D3D3">
        </div>
        <div class="control-group">
            <label>Tetra Opacity:</label>
            <input type="number" id="tetraOpacity" value="0.01" min="0.0" max="1.0" step="0.01">
        </div>
        <div class="control-group">
            <label>Voronoi Face Color:</label>
            <input type="color" id="voronoiFaceColor" value="#ADD8E6">
        </div>
        <div class="control-group">
            <label>Voronoi Face Opacity:</label>
            <input type="number" id="voronoiFaceOpacity" value="0.04" min="0.0" max="1.0" step="0.01">
        </div>
        <hr>
        <div class="control-group">
            <label>Show Vertices:</label>
            <input type="checkbox" id="showVertices" checked>
        </div>
        <div class="control-group">
            <label>Show Delaunay:</label>
            <input type="checkbox" id="showDelaunay" checked>
        </div>
        <div class="control-group">
            <label>Show Voronoi:</label>
            <input type="checkbox" id="showVoronoi" checked>
        </div>
        <div class="control-group">
            <label>Show Tetrahedra:</label>
            <input type="checkbox" id="showTetrahedra" checked>
        </div>
        <div class="control-group">
            <label>Show Boundary:</label>
            <input type="checkbox" id="showBoundary" checked>
        </div>
        <div class="control-group">
            <label>Show Voronoi Faces:</label>
            <input type="checkbox" id="showVoronoiFaces" checked>
        </div>
        <hr>
        <button id="regenerate">Generate New Points</button>
        <button id="recompute">Recompute Triangulation</button>
        <div id="status" class="status"></div>
    </div>
    
    <script src="../../dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { DelaunayComputation } from '../../src/js/DelaunayComputation.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiGroup, tetrahedraGroup, boundaryGroup, voronoiFacesGroup;
        let Module;
        let currentPoints = [];
        let computation = null;
        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            
            scene.add(verticesGroup);
            scene.add(delaunayGroup);
            scene.add(voronoiGroup);
            scene.add(tetrahedraGroup);
            scene.add(boundaryGroup);
            scene.add(voronoiFacesGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers
            const axesHelper = new THREE.AxesHelper(0.2);
            scene.add(axesHelper);
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }
        
        // Visualize vertices
        function drawVertices(computation) {
            verticesGroup.clear();
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            
            const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: vertexColorInt });
            
            for (const point of computation.pointsArray) {
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(point[0], point[1], point[2]);
                verticesGroup.add(sphere);
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(computation) {
            delaunayGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const edgeSet = new Set();
            const material = new THREE.LineBasicMaterial({ color: 0x0066ff });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0099ff, 
                linewidth: 2 
            });
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]],
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        
                        // Get vertex positions
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        // Check if edge crosses periodic boundary
                        const isPeriodic = computation._isPeriodicEdge(p1, p2);
                        
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            p1[0], p1[1], p1[2],
                            p2[0], p2[1], p2[2]
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const line = new THREE.Line(
                            geometry, 
                            isPeriodic ? periodicMaterial : material
                        );
                        delaunayGroup.add(line);
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            const voronoiColorHex = document.getElementById('voronoiColor').value;
            const voronoiColorInt = parseInt(voronoiColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt,
                linewidth: 2 
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt, 
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiColorInt,
                emissive: voronoiColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.clear();
            
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the barycenters of tetrahedra that contain it
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const barycenter = computation.barycenters[index];
                if (!barycenter) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...barycenter));
                });
            });

            // For each cell, compute the convex hull of its vertices (the barycenters)
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return; // Need at least 4 points for a 3D shape

                // Create a convex geometry from the vertices of the Voronoi cell
                const geometry = new ConvexGeometry(cellVertices);
                const mesh = new THREE.Mesh(geometry, material);
                voronoiFacesGroup.add(mesh);
            });
        }
        
        // Unified mesh drawing function that properly handles periodic edges
        function drawMeshes(computation) {
            delaunayGroup.clear();
            voronoiGroup.clear();
            voronoiFacesGroup.clear();

            console.log(`Drawing meshes for ${computation.isPeriodic ? 'PERIODIC' : 'NON-PERIODIC'} mode`);

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt, linewidth: 2, opacity: 0.6, transparent: true });

            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges ---
            const delaunayEdgeSet = new Set();
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            // Calculate the minimum image distance
                            const p2min = getMinimumImage(p1, p2);
                            const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                            
                            if (isPeriodic) {
                                periodicEdgeCount++;
                                // Draw periodic edge properly clipped at boundaries
                                for (let dim = 0; dim < 3; dim++) {
                                    const diff = p2[dim] - p1[dim];
                                    if (Math.abs(diff) > 0.5) {
                                        // This dimension wraps
                                        const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                        
                                        // Clamp t to avoid numerical issues
                                        const tClamped = Math.max(0.001, Math.min(0.999, t));
                                        
                                        const midPoint = [
                                            p1[0] + tClamped * (p2[0] - p1[0]),
                                            p1[1] + tClamped * (p2[1] - p1[1]),
                                            p1[2] + tClamped * (p2[2] - p1[2])
                                        ];
                                        
                                        // Ensure midPoint is exactly at boundary
                                        midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                        
                                        // Draw first segment to boundary
                                        const geom1 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...p1),
                                            new THREE.Vector3(...midPoint)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom1, delaunayPeriodicMaterial));
                                        
                                        // Calculate corresponding point on opposite boundary
                                        const oppositePoint = [...midPoint];
                                        oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                        
                                        // Draw second segment from opposite boundary
                                        const geom2 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...oppositePoint),
                                            new THREE.Vector3(...p2)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom2, delaunayPeriodicMaterial));
                                        
                                        break; // Only handle the first wrapping dimension
                                    }
                                }
                            } else {
                                regularEdgeCount++;
                                // Regular edge within the box
                                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1), 
                                    new THREE.Vector3(...p2)
                                ]);
                                delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                            }
                        } else {
                            // Regular edge
                            const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...p1), 
                                new THREE.Vector3(...p2)
                            ]);
                            delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                        }
                    }
                }
            }

            console.log(`Drew ${periodicEdgeCount} periodic edges out of ${delaunayEdgeSet.size} total Delaunay edges`);
            
            // --- Draw Voronoi Edges ---
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    // Calculate the minimum image distance
                    const p2min = getMinimumImage(p1, p2);
                    const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                    
                    if (isPeriodic) {
                        // Draw periodic edge properly clipped at boundaries
                        for (let dim = 0; dim < 3; dim++) {
                            const diff = p2[dim] - p1[dim];
                            if (Math.abs(diff) > 0.5) {
                                // This dimension wraps
                                const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                
                                // Clamp t to avoid numerical issues
                                const tClamped = Math.max(0.001, Math.min(0.999, t));
                                
                                const midPoint = [
                                    p1[0] + tClamped * (p2[0] - p1[0]),
                                    p1[1] + tClamped * (p2[1] - p1[1]),
                                    p1[2] + tClamped * (p2[2] - p1[2])
                                ];
                                
                                // Ensure midPoint is exactly at boundary
                                midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                
                                // Draw first segment to boundary
                                const geom1 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1),
                                    new THREE.Vector3(...midPoint)
                                ]);
                                voronoiGroup.add(new THREE.Line(geom1, voronoiPeriodicMaterial));
                                
                                // Calculate corresponding point on opposite boundary
                                const oppositePoint = [...midPoint];
                                oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                
                                // Draw second segment from opposite boundary
                                const geom2 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...oppositePoint),
                                    new THREE.Vector3(...p2)
                                ]);
                                voronoiGroup.add(new THREE.Line(geom2, voronoiPeriodicMaterial));
                                break; // Only handle the first wrapping dimension
                            }
                        }
                    } else {
                        // Regular edge within the box
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...p1), 
                            new THREE.Vector3(...p2)
                        ]);
                        voronoiGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                    }
                } else {
                    // Regular edge within the box
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...p1), 
                        new THREE.Vector3(...p2)
                    ]);
                    voronoiGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                }
            }
            
            // Draw Voronoi vertices (barycenters)
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                const vertices = tet.map(i => computation.pointsArray[i]);
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // Compute Delaunay-Voronoi
        async function computeDelaunayVoronoi() {
            if (!Module) return;
            
            // Diagnostic check for corrupt input data
            console.log("--- New Computation Triggered ---");
            console.log(`Checking ${currentPoints.length} points before sending to WASM.`);
            let outliersFound = 0;
            for (const p of currentPoints) {
                if (!p || p.length !== 3 || p[0] < 0 || p[0] > 1 || p[1] < 0 || p[1] > 1 || p[2] < 0 || p[2] > 1) {
                    console.error("🔴 OUTLIER DETECTED! This point is outside the [0, 1] unit cube and will corrupt the periodic triangulation:", p);
                    outliersFound++;
                }
            }
            if (outliersFound > 0) {
                console.error(`Found ${outliersFound} outlier points. Halting computation.`);
                setStatus(`Error: Found ${outliersFound} outlier points.`, false);
                return; // Stop execution if data is bad
            }
            console.log("✅ Point data is clean. Proceeding with computation...");
            
            const isPeriodic = document.getElementById('periodicMode').checked;
            
            setStatus('Computing...', false);
            
            try {
                // Create computation instance
                computation = new DelaunayComputation(currentPoints, isPeriodic);
                
                // Run the computation
                await computation.compute(Module);
                
                // Get statistics
                const stats = computation.getStats();
                setStatus(`Success! ${stats.numTetrahedra} tetrahedra, ${stats.numVoronoiEdges} Voronoi edges`, true);
                
                // Update visualization
                drawVertices(computation);
                drawMeshes(computation);
                drawTetrahedra(computation);
                drawVoronoiFaces(computation); // Ensure this is called
                
                updateStats();
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, false);
                console.error(error);
            }
        }
        
        // Update statistics
        function updateStats() {
            if (!computation) return;
            
            const stats = computation.getStats();
            document.getElementById('stats').innerHTML = `
                <strong>Mode:</strong> ${stats.isPeriodic ? 'Periodic' : 'Non-periodic'}<br>
                <strong>Vertices:</strong> ${stats.numPoints}<br>
                <strong>Tetrahedra:</strong> ${stats.numTetrahedra}<br>
                <strong>Voronoi Edges:</strong> ${stats.numVoronoiEdges}
            `;
        }
        
        // Set status message
        function setStatus(message, isSuccess) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(module => {
            Module = module;
            setStatus('Module loaded', true);
            
            initThree();
            
            // Generate initial points
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            const usePoisson = document.getElementById('poissonSampling').checked;
            const points = usePoisson ? 
                generatePoissonPoints(numPoints, minDist) : 
                generateWellDistributedPoints(numPoints, minDist);
            currentPoints = points;
            
            computeDelaunayVoronoi();
            
            // Set up event listeners
            document.getElementById('showVertices').addEventListener('change', (e) => {
                verticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showDelaunay').addEventListener('change', (e) => {
                delaunayGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoi').addEventListener('change', (e) => {
                voronoiGroup.visible = e.target.checked;
            });
            
            document.getElementById('showTetrahedra').addEventListener('change', (e) => {
                tetrahedraGroup.visible = e.target.checked;
            });
            
            document.getElementById('showBoundary').addEventListener('change', (e) => {
                boundaryGroup.visible = e.target.checked;
            });

            document.getElementById('voronoiFaceColor').addEventListener('change', () => {
                drawVoronoiFaces(computation);
            });
            
            document.getElementById('voronoiFaceOpacity').addEventListener('change', () => {
                drawVoronoiFaces(computation);
            });
            
            document.getElementById('showVoronoiFaces').addEventListener('change', (e) => {
                voronoiFacesGroup.visible = e.target.checked;
            });
            
            document.getElementById('regenerate').addEventListener('click', () => {
                const numPoints = parseInt(document.getElementById('numPoints').value);
                const minDist = parseFloat(document.getElementById('minDistance').value);
                const usePoisson = document.getElementById('poissonSampling').checked;
                const points = usePoisson ? 
                    generatePoissonPoints(numPoints, minDist) : 
                    generateWellDistributedPoints(numPoints, minDist);
                currentPoints = points;
                computeDelaunayVoronoi();
            });
            
            document.getElementById('recompute').addEventListener('click', () => {
                computeDelaunayVoronoi();
            });
            
            document.getElementById('periodicMode').addEventListener('change', () => {
                computeDelaunayVoronoi();
            });
            
            // Size and color controls
            document.getElementById('delaunaySize').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('vertexColor').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('delaunayEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('voronoiSize').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('voronoiVertexColor').addEventListener('change', () => {
                drawMeshes(computation);
            });

            document.getElementById('voronoiEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('tetraColor').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            document.getElementById('tetraOpacity').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            animate();
            
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 